<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编译器设计及实现</title>
    <style>
        table {
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid;
            padding: 0 1rem;
            text-align: center;
        }

        .emphasize,
        em {
            color: tomato;
        }

        .stress {
            color: red;
        }

        .legend {
            display: inline-block;
            font-size: small;
        }
    </style>
</head>

<body>
    <p>小心,这是一堆抽象的东西</p>
    <p>目前已经实现了编程语言ty,可以上<a href="https://github.com/yangzhenzhuozz/ty">github</a>看看</p>
    <h1>乔姆斯基体系(chomsky hierarchy)</h1>
    <p>提起编译原理,就不得不先说说文法。</p>
    <blockquote>
        <p>文法自然地描述了大多数程序设计语言构造的层次化语法结构</p>
        <footer> <cite>-编译原理(龙书)-p26</cite></footer>
    </blockquote>
    <p>假设我们要描述这样一个东西:"一个加法的数学表达式由两个数字和加号运算符组成",我们可以用如下的一条文法规则描述:</p>
    <math>
        <mi>EXP</mi>
        <mo>→</mo>
        <mi>num</mi>
        <mo>+</mo>
        <mi>num</mi>
    </math>
    <p>上面式子中的EXP表示一个表达式,num表示一个数字,所以"1+2"、"5+6"这些内容都符合EXP的展开规则,如果我们再扩展一下:</p>
    <ol>
        <li>
            <math>
                <mi>EXP</mi>
                <mo>→</mo>
                <mi>EXP</mi>
                <mo>+</mo>
                <mi>EXP</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>EXP</mi>
                <mo>→</mo>
                <mo>(</mo>
                <mi>EXP</mi>
                <mo>)</mo>
            </math>
        </li>
        <li>
            <math>
                <mi>EXP</mi>
                <mo>→</mo>
                <mi>NUM</mi>
            </math>
        </li>
    </ol>
    <p>那么对于"1+(2+3)"这样的内容也完全符合上述文法规则,这个内容会被解析成如下的一颗语法树:</p>
    <svg style="height: 200PX;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 121.59 122.12"><text
            transform="translate(43.51 118.23)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">2</text><text
            transform="translate(35.26 99.02)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">NUM</text>
        <line x1="75.58" y1="71.34" x2="75.58" y2="63.34" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="75.58" y1="46.05" x2="75.58" y2="38.05" style="fill:none;stroke:#231815;stroke-miterlimit:10" /><text
            transform="translate(103.51 118.09)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">3</text>
        <line x1="39.98" y1="21.78" x2="39.98" y2="12.78" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="106.28" y1="90.04" x2="106.28" y2="85.04" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="46.93" y1="90.04" x2="46.93" y2="85.04" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="46.28" y1="107.07" x2="46.28" y2="102.07" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="106.28" y1="107.07" x2="106.28" y2="102.07" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <text transform="translate(94.26 99.02)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">NUM</text><text
            transform="translate(65.75 59.69)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text><text
            transform="translate(95.75 82.02)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text><text
            transform="translate(35.75 82.02)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text><text
            transform="translate(8.25 71.06)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">1</text><text
            transform="translate(0 51.85)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">NUM</text>
        <line x1="11.02" y1="42.87" x2="11.02" y2="37.87" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="11.02" y1="59.9" x2="11.02" y2="54.9" style="fill:none;stroke:#231815;stroke-miterlimit:10" /><text
            transform="translate(0.5 34.85)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text><text
            transform="translate(65.75 34.85)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text><text
            transform="translate(30.5 10.3)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">EXP</text>
        <line x1="65.01" y1="38.05" x2="54.15" y2="46.09" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="25.07" y1="12.78" x2="14.21" y2="20.81" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="86.15" y1="38.05" x2="97.01" y2="46.09" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="54.9" y1="12.78" x2="65.75" y2="20.81" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="65.01" y1="63.33" x2="54.15" y2="71.36" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <line x1="86.15" y1="63.33" x2="97.01" y2="71.36" style="fill:none;stroke:#231815;stroke-miterlimit:10" /><text
            transform="translate(44.03 59.69)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">(</text><text
            transform="translate(104.03 59.69)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">)</text><text
            transform="translate(72.65 82.02)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">+</text><text
            transform="translate(36.35 34.85)"
            style="isolation:isolate;font-size:12px;fill:#231815;font-family:ArialMT, Arial">+</text>
    </svg>
    <p>接着上面用到的文法,再介绍几个名词:(以下内容参考wikiPedia的<q cite="https://en.wikipedia.org/wiki/Chomsky_hierarchy"><a
                href="https://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky
                hierarchy</a></q>和<q><a href="https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols">Terminal
                and nonterminal symbols</a></q>)</p>
    <ol>
        <li>开始符号(start symbol):一个特意指定的符号,表示整个文法结构。在上面的例子中没有特意指定S符号,但是可以理解,我们最终会把整颗语法树规约成EXP,所以EXP就是上述文法的开始符号</li>
        <li>非终结符(non-terminal symbol):一个可以被推导(repalce)的符号。比如上面我们在解析"1+(2+3)"的时候把NUM推导成了2,把EXP推导成了(EXP+EXP)</li>
        <li>终结符(terminal symbol):一个不允许被推导的符号。如上面解析过程中的'+'、'('、')'都是不允许推导的。<em>在后面的内容中,将会用ε表示一个特殊的空终结符,这个符号表示什么内容都没有</em>
        </li>
        <li>产生式(production rule):指定了符号的推导规则。上面的两个文法定义,共4条规则都是产生式</li>
    </ol>
    <p>有了上述概念,我们可以模仿着写出java语言的if语句规则:(按照一些习惯,我用大写字母表示非终结符,小写字母表示终结符,希腊字母表示一个串,实际上这不是强制的)</p>
    <ol>
        <li>
            <math>
                <mi>STMT</mi>
                <mo>→</mo>
                <mi>if</mi>
                <mo>(</mo>
                <mi>EXP</mi>
                <mo>)</mo>
                <mi>STMT</mi>
            </math>
        </li>
    </ol>
    <p>上述规则可以描述这样的语句:</p>
    <code>
        <div>
            if ( condition ) stmt
        </div>
    </code>
    <p>甚至还可以表示if的嵌套:</p>
    <code>
        <div>
            if ( condition )
        </div>
        <div>
            &nbsp;&nbsp;if ( condition ) stmt
        </div>
    </code>
    <p>因为if语句本身又是一个STMT</p>
    <p>乔姆斯基体系将文法分为四个层级:0-型文法、1-型文法、2-型文法、3-型文法。对于0-型和1-型文法,我也没什么研究,简单了解一下即可,计算机编程语言主要使用的就是2-型文法(上下文无关文法)和3-型文法(正规文法)</p>
    <ol>
        <li>
            <span>0-型文法:</span>
            <p>Type-0 文法包括所有的形式文法。描述了所有可以被图灵机识别的语言。这些语言同时也被称为递归可枚举或图灵可识别的语言--
                <q cite="https://en.wikipedia.org/wiki/Recursively_enumerable_language">
                    <a href="https://en.wikipedia.org/wiki/Recursively_enumerable_language">
                        recursively enumerable or Turing-recognizable languages
                    </a>
                </q>
            </p>
        </li>
        <li>
            <span>1-型文法</span>
            <p>Type-1文法可以生成上下文相关语言,这种文法描述的语言可以使用线性有界自动机描述。--
                <q cite="https://en.wikipedia.org/wiki/Context-sensitive_grammar">
                    <a href="https://en.wikipedia.org/wiki/Context-sensitive_grammar">
                        Context-sensitive grammar
                    </a>
                </q>
            </p>
            <ol>
                <li>
                    <math>
                        <mi>α</mi>
                        <mi>A</mi>
                        <mi>β</mi>
                        <mo>→</mo>
                        <mi>α</mi>
                        <mi>γ</mi>
                        <mi>β</mi>
                    </math>
                </li>
                <li>
                    <math>
                        <mi>θ</mi>
                        <mi>A</mi>
                        <mi>λ</mi>
                        <mo>→</mo>
                        <mi>α</mi>
                        <mi>ξ</mi>
                        <mi>β</mi>
                    </math>
                </li>
            </ol>
            <p>同样的一个符号A,当他前面是α且后面是β时,才把A替换成γ,要是A的前面是θ后面是λ,则将其替换成ξ(即非终结符的替换需要考虑这个非终结符所在的上下文)</p>
        </li>
        <li>
            <span>2-型文法</span>
            <p>Type-2文法可生成上下无关语言,他的非终结符替换不需要考虑。--
                <q cite="https://en.wikipedia.org/wiki/Context-free_grammar">
                    <a href="https://en.wikipedia.org/wiki/Context-free_grammar">
                        Context-free_grammar
                    </a>
                </q>
            </p>
            <p>上下文无关文法的产生式规则如下:</p>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>α</mi>
            </math>
            <p>一条即产生式规则的左侧有且仅有一个非终结符。我们可以发现这里不需要考虑这个非终结符的上下文,这为我们设计计算机编程语言提供了非常大的方便,比如C#中有这样一行代码</p>
            <div>a * b</div>
            <p>编译器可以立马识别到这是一个对象a和一个对象b进行了*操作,简单理解就是看到了符号*,那么他可以立即理解为*操作符。而这种语法在C/C++上,还需要考虑a是否为一种自定义类型,如果a是自定义类型的话,这行语句应当是声明一个指针。当然针对C/C++这种程度的上下文相关,我们可以对编译器做一些针对性调整,使其在输入阶段变为上下文无关。
            </p>
        </li>
        <li>
            <span>3-型文法</span>
            <p>Type-3文法也叫做正规文法(regular grammar),正规文法也分为左正规文法和右正规文法,他们之间没有多大差异。参考--<q
                    cite="https://en.wikipedia.org/wiki/Regular_grammar">
                    <a href="https://en.wikipedia.org/wiki/Regular_grammar">
                        Regular_grammar
                    </a>
                </q>
            </p>
            <p>一个右正规文法的产生式必须是如下的形式:</p>
            <ol>
                <li>
                    <math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>a</mi>
                    </math>
                </li>
                <li>
                    <math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>aB</mi>
                    </math>
                </li>
                <li>
                    <math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>ε</mi>
                    </math>
                </li>
            </ol>
            <p>如果把第二条规则定义成
                <math>
                    <mi>A</mi>
                    <mo>→</mo>
                    <mi>Ba</mi>
                </math>
                ,那么这个文法就是左正规文法。正规文法要求一个非终结符①要么能替换成一个终结符,②要么能替换成一个终结符和右侧的一个非终结符(如果这个非终结符在左侧,就是左正规文法),③或者这个非终结符能推导出一个空终结符。3-型文法的表达能力和正则表达式(regular
                expression)完全一致。比如我们写这样一个正则表达式"a*b",我们可以构造如下的3-型文法表示:
            </p>
            <ol>
                <li><math>
                        <mi>S</mi>
                        <mo>→</mo>
                        <mi>A</mi>
                        <mi>b</mi>
                    </math></li>
                <li><math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>a</mi>
                    </math></li>
                <li><math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>a</mi>
                        <mi>A</mi>
                    </math></li>
                <li><math>
                        <mi>A</mi>
                        <mo>→</mo>
                        <mi>ε</mi>
                    </math></li>
            </ol>
            <p>这也是3-型文法叫做正规文法的原因</p>
        </li>
    </ol>
    <p>乔姆斯基体系的每一层文法表达能力都涵盖了下一层,也就是随着数字的增加,文法的表达能力逐渐减小:</p>
    <svg style="height: 300PX;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 438.5 407.07">
        <ellipse cx="219.25" cy="218.02" rx="218.75" ry="188.54"
            style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <ellipse cx="219.25" cy="265.94" rx="157.29" ry="140.63"
            style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <ellipse cx="219.25" cy="310.38" rx="110.76" ry="96.18" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <ellipse cx="219.25" cy="344.76" rx="56.6" ry="61.81" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
        <g style="isolation:isolate"><text transform="translate(164.21 78.37)"
                style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">Recursively
            </text><text transform="translate(164.21 107.17)"
                style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">enumerable</text></g>
        <text transform="translate(137.72 191.55)"
            style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">Context-sensitive</text><text
            transform="translate(159.4 255.99)"
            style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">Context-free</text><text
            transform="translate(183.41 346.44)"
            style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">Regular</text><text
            transform="translate(126.65 20.6)"
            style="isolation:isolate;font-size:24px;fill:#231815;font-family:ArialMT, Arial">Chomsky hierarchy</text>
    </svg>
    <p>通过上面的说明,我们可以知道一件有趣的事:<em>永远不可能用正则表达式判断一个字符串是否为一个合法的正则表达式</em></p>
    <h1>编译器结构</h1>
    <p>前面说了这么多铺垫,都是为了打一下基础。一般可以把编译器的分析-综合模型粗略的分为前端和后端(参考龙书第六章和第八章的开头)</p>
    <div style="width: 600px;text-align: center;">
        <svg data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600.89 70.71"><text
                transform="translate(31.58 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">词法分析</text>
            <rect x="25.43" y="0.5" width="60.3" height="24.6" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <text transform="translate(120.31 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">文法分析</text>
            <rect x="114.16" y="0.5" width="60.3" height="24.6" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <text transform="translate(209.04 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">语义检查</text>
            <rect x="202.89" y="0.5" width="60.3" height="24.6" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <text transform="translate(297.6 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">中间代码生成</text>
            <rect x="291.62" y="0.5" width="83.97" height="24.6"
                style="fill:none;stroke:#231815;stroke-miterlimit:10" /><text transform="translate(522.41 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">目标代码生成</text>
            <rect x="516.42" y="0.5" width="83.97" height="24.6"
                style="fill:none;stroke:#231815;stroke-miterlimit:10" /><text transform="translate(410.01 16.55)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">中间代码优化</text>
            <rect x="404.02" y="0.5" width="83.97" height="24.6"
                style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <line x1="88.73" y1="12.8" x2="102.3" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="100.32 15.7 111.16 12.8 100.32 9.89 100.32 15.7" style="fill:#231815" />
            <line y1="12.8" x2="13.57" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="11.59 15.7 22.43 12.8 11.59 9.89 11.59 15.7" style="fill:#231815" />
            <line x1="177.46" y1="12.8" x2="191.03" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="189.05 15.7 199.89 12.8 189.05 9.89 189.05 15.7" style="fill:#231815" />
            <line x1="266.19" y1="12.8" x2="279.76" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="277.78 15.7 288.62 12.8 277.78 9.89 277.78 15.7" style="fill:#231815" />
            <line x1="378.59" y1="12.8" x2="392.16" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="390.18 15.7 401.02 12.8 390.18 9.89 390.18 15.7" style="fill:#231815" />
            <line x1="490.99" y1="12.8" x2="504.56" y2="12.8" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="502.58 15.7 513.42 12.8 502.58 9.89 502.58 15.7" style="fill:#231815" />
            <line x1="389.81" y1="33.43" x2="389.81" y2="70.71" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <line x1="4.33" y1="64.76" x2="377.95" y2="64.76" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="375.96 67.67 386.81 64.76 375.96 61.86 375.96 67.67" style="fill:#231815" />
            <line x1="598.87" y1="64.76" x2="401.67" y2="64.76" style="fill:none;stroke:#231815;stroke-miterlimit:10" />
            <polygon points="403.65 61.86 392.81 64.76 403.65 67.67 403.65 61.86" style="fill:#231815" /><text
                transform="translate(193.81 61.72)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">前端</text><text
                transform="translate(483.84 61.72)"
                style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">后端</text>
        </svg>
        <span class="legend">编译器模型</span>
    </div>
    <p>所以我们可以一步一步的剖析这些流程。</p>
    <h1>词法分析</h1>
    <p>编译器的词法分析阶段可以用很多技术,当然很多编译器都是使用正规语言作为一个词法分析器,因为正则表达式比较容易编写。考虑一下开始我们说的加法,如果我们要解析"1+(2+3)"这个源码,那么我们需要把这个输入依次转换为:</p>
    <table>
        <tbody>
            <tr>
                <td>num</td>
                <td>+</td>
                <td>(</td>
                <td>num</td>
                <td>+</td>
                <td>num</td>
                <td>)</td>
            </tr>
        </tbody>
    </table>
    <p>那么我们可以编写如下的正则规则:</p>
    <table>
        <tbody>
            <tr>
                <td>num</td>
                <td>[0-9]+</td>
            </tr>
            <tr>
                <td>left bracket</td>
                <td>'('</td>
            </tr>
            <tr>
                <td>right bracket</td>
                <td>')'</td>
            </tr>
            <tr>
                <td>add operator</td>
                <td>'+'</td>
            </tr>
        </tbody>
    </table>
    <p>所以首先需要做的就是实现我们自己的正则解析器。为了实现正则解析,可以借助两个工具NFA(non-deterministic finite automaton)和DFA(deterministic finite
        automaton)</p>
    <h2>NFA</h2>
    <p>NFA的定义很简单,满足如下几个条件即可</p>
    <ol>
        <li>有限的状态集合(finite的由来)</li>
        <li>输入字母表</li>
        <li>状态转换函数,定义了每一个状态对于字母表中字母的后继状态</li>
        <li>一个开始和结束状态</li>
    </ol>
    <p>这么说是不是很抽象,举个例子其实就很简单明了了,假设我们有如下一个nfa,我们说明一下NFA的工作机制。</p>
    <ol>
        <li>在最开始的时候,状态机总是处于start状态</li>
        <li>状态机总是记录着当前处于那些状态(一个状态集)</li>
        <li>如果当前状态集任意一条边(状态转移函数)能接受某个输入字母a,则将所有这些边的目标状态到一个集合中,并且使这个集合作为当前集合对于输入字母a的后继集合</li>
        <li>如果最终状态机停止的时候,当前状态集中包含了end状态,则说明这个NFA接受的输入的字符串</li>
    </ol>
    <p>需要特别注意的是:<em>ε表示一个空符号,如果ε出现在状态机的某条边上,表示可以无条件从前一个状态沿这条边到达后继状态</em></p>
    <p>在下面我做了动画演示,处理字母序列'aab'和'b'的情况</p>
    <div id="NFA-1">
        <template>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 625 189.22" style="height: 300px;">
                <defs>
                    <style>
                        .cls-1 {
                            fill: none;
                            stroke: #000;
                            stroke-miterlimit: 10;
                        }

                        .cls-2 {
                            font-size: 12px;
                        }

                        .cls-2,
                        .cls-3 {
                            font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;
                        }

                        .cls-3 {
                            font-size: 18px;
                        }
                    </style>
                </defs>
                <g class="arrow" id="p_0_1">
                    <line class="cls-1" x1="105" y1="102.5" x2="141.14" y2="102.5" pathLength="100" />
                    <polygon points="139.16 105.4 150 102.5 139.16 99.59 139.16 105.4" />
                </g>
                <g class="arrow" id="p_1_2">
                    <line class="cls-1" x1="210" y1="102.5" x2="246.14" y2="102.5" pathLength="100" />
                    <polygon points="244.16 105.4 255 102.5 244.16 99.59 244.16 105.4" />
                </g>
                <g class="arrow" id="p_2_3">
                    <line class="cls-1" x1="315" y1="102.5" x2="351.14" y2="102.5" pathLength="100" />
                    <polygon points="349.16 105.4 360 102.5 349.16 99.59 349.16 105.4" />
                </g>
                <g class="arrow" id="p_3_4">
                    <line class="cls-1" x1="420" y1="102.5" x2="456.14" y2="102.5" pathLength="100" />
                    <polygon points="454.16 105.4 465 102.5 454.16 99.59 454.16 105.4" />
                </g>
                <g class="arrow" id="p_4_5">
                    <line class="cls-1" x1="525" y1="102.5" x2="561.14" y2="102.5" pathLength="100" />
                    <polygon points="559.16 105.4 570 102.5 559.16 99.59 559.16 105.4" />
                </g>
                <g class="arrow" id="p_2_1">
                    <path class="cls-1" d="M285,72.5C285,3.73,188.81.78,180.56,63.65" pathLength="100" />
                    <polygon points="177.87 61.48 180 72.5 183.66 61.89 177.87 61.48" />
                </g>
                <g class="arrow" id="p_0_3">
                    <path class="cls-1" d="M75,132.5q153.5,74.3,307,3.78" pathLength="100" />
                    <polygon points="381.33 139.62 390 132.5 378.93 134.33 381.33 139.62" />
                </g><text class="cls-2" transform="translate(230 94.45)">a</text><text class="cls-2"
                    transform="translate(544.48 94.45)">b</text><text class="cls-2"
                    transform="translate(226.5 10.56)">ε</text><text class="cls-2"
                    transform="translate(331.5 94.45)">ε</text><text class="cls-2"
                    transform="translate(436.5 94.45)">ε</text><text class="cls-2"
                    transform="translate(121.5 94.45)">ε</text><text class="cls-2"
                    transform="translate(226.5 186.18)">ε</text>
                <g class="state" id="state0">
                    <circle class="cls-1" cx="75" cy="102.5" r="25" /><text class="cls-3"
                        transform="translate(60.16 108.13)">start</text>
                </g>
                <g class="state" id="state1">
                    <circle class="cls-1" cx="180" cy="102.5" r="25" /><text class="cls-3"
                        transform="translate(175.84 108.13)">1</text>
                </g>
                <g class="state" id="state2">
                    <circle class="cls-1" cx="285" cy="102.5" r="25" /><text class="cls-3"
                        transform="translate(280.84 108.13)">2</text>
                </g>
                <g class="state" id="state3">
                    <circle class="cls-1" cx="390" cy="102.5" r="25" /><text class="cls-3"
                        transform="translate(385.84 108.13)">3</text>
                </g>
                <g class="state" id="state4">
                    <circle class="cls-1" cx="495" cy="102.5" r="25" /><text class="cls-3"
                        transform="translate(490.84 108.13)">4</text>
                </g>
                <g class="state" id="state5">
                    <path
                        d="M600,81a21.5,21.5,0,1,1-21.5,21.5A21.52,21.52,0,0,1,600,81m0-1a22.5,22.5,0,1,0,22.5,22.5A22.5,22.5,0,0,0,600,80Z"
                        style="stroke-width:0;" />
                    <path style="stroke-width:0;"
                        d="M600,78.5a24,24,0,1,1-24,24,24,24,0,0,1,24-24m0-1a25,25,0,1,0,25,25,25,25,0,0,0-25-25Z" />
                    <text class="cls-3" transform="translate(586.76 108.13)">end</text>
                </g>
                <g class="arrow" id="p_0_0">
                    <line class="cls-1" y1="102.5" x2="36.14" y2="102.5" pathLength="100" />
                    <polygon points="34.16 105.4 45 102.5 34.16 99.59 34.16 105.4" />
                </g>
            </svg>
            <div>
                <span>这里有上面NFA处理两个字符串的示意图,可以点击下一步观看</span><br />
                <table>
                    <tbody>
                        <tr>
                            <td><span>aab</span></td>
                            <td><button id="aab">下一步</button></td>
                        </tr>
                        <tr>
                            <td><span>b</span></td>
                            <td><button id="b">下一步</button></td>
                        </tr>
                    </tbody>
                </table>
                <span>当前状态集: </span><span id="now"></span><br />
                <span>当前可接受字母: </span><span id="letters"></span><br />
                <span>处理字母: </span><span id="letter" style="color: red;"></span><br />
            </div>
        </template>
    </div>
    <p>通过上面动画,我们可以发现这个nfa和正则表达式"a*b"是完全等价的,实际上任何基本正则表达式都是能完全转化为NFA的,他们的表达能力一致。基本正则是指没有加上开发者自己的扩展功能,比如匹配到单词"boom"就在屏幕放一个烟花,或者其他特殊语法。实际上一些扩展功能,比如分组匹配在nfa中也是存在的,在NFA转换成DFA的过程中会丢失一些信息使得类似分组匹配这些功能失效。基本正则简称BRE,被扩展过的叫做ERE。参考--
        <q cite="https://en.wikipedia.org/wiki/Regular_expression#Standards">
            <a href="https://en.wikipedia.org/wiki/Regular_expression#Standards">Regular expression</a>
        </q>
    </p>
    <p><em>这里只是我对BRE和ERE的的理解,来不及查阅文献了,应该不会偏差太多 ƪ(˘⌣˘)ʃ</em></p>
    <p>基本正则表达式只包含如下三种结构</p>
    <ol>
        <li>连接,如:abc就表示"a连接b得到的一个表达式再连接c",也就是解析这个式子之后得到的结构应该是这样的(ab)c</li>
        <li>并,如:a|b</li>
        <li>克林闭包,如:a*</li>
    </ol>
    <p>而类似a+这种语法是ERE里面才有的。</p>
    <h2>克林闭包(Kleene closure)</h2>
    <p>
        <a href="https://en.wikipedia.org/wiki/Kleene_star">克林闭包</a>
        在计算机科学中也扮演着重要的角色,不管是做正则引擎还是后面会说的上下文无关文法分析器,以及在关系数据库中计算一个关系R的候选码的时候,都会用到这个概念。
    </p>
    <h3>某个状态集合s的克林闭包的计算方法:</h3>
    closure(s)
    <ol>
        <li>将s中的所有状态添加到待扫描列表(new_state_list)中</li>
        <li>for(new_state_list中的每一个项now)</li>
        <ol>
            <li>for(所有以now为起点的ε边)</li>
            <ol>
                <li>判断该ε边的后继状态t是否已经存在于s中</li>
                <ul>
                    <li>如果t不存在于s中,则将t添加到s和new_state_list</li>
                    <li>否则不需要做任何事</li>
                </ul>
            </ol>
        </ol>
    </ol>
    <h2>正则表达式到NFA的转换</h2>
    <p>为什么要将正则表达式转换为NFA呢?<em>因为直接编写正则表达式的处理程序是比较困难的,借助NFA这种状态机的思想,我们就可以比较简单的通过状态转换实现正则表达式的功能。</em>有的编程语言在用正则表达式的时候会有一个编译步骤,比如java的Pattern.compile,编译过程一般就是将用户输入的正则表达式编译成状态机(这句话我不负法律责任,我凭经验猜的,所以前面加了"一般"两个字)
    </p>
    <p>前面已经提过,正则表达式和NFA的能力一致,所以存在将正则转换为NFA的方法。在本教程里面,我们只考虑基本正则表达式到NFA的转换。需要注意的是:<em>我在下面做的转换可能存在一些冗余,比如两个子表达式连接的时候,前一个子串的end状态和后一个子串的start状态也可以合并,所以我这种转换方法不是唯一解决方案。</em>
    </p>
    <ol>
        <li>
            <p>对于任何一个正则,我们可以构造这样一个NFA</p>
            <svg data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 270.5 51" style="height: 60px;">
                <defs>
                </defs>
                <style>
                    @scope {
                        .cls-1 {
                            fill: none;
                        }

                        .cls-1,
                        .cls-4 {
                            stroke: #231815;
                            stroke-miterlimit: 10;
                        }

                        .cls-2 {
                            font-size: 12px;
                            font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;
                        }

                        .cls-2,
                        .cls-3 {
                            fill: #231815;
                        }

                        .cls-4 {
                            fill: #fff;
                        }
                    }
                </style>
                <circle class="cls-1" cx="70" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(60.11 29.26)">start</text>
                <circle class="cls-1" cx="230" cy="25.5" r="25" />
                <circle class="cls-1" cx="230" cy="25.5" r="23" />
                <text class="cls-2" transform="translate(221.17 29.26)">end</text>
                <line class="cls-1" y1="25.5" x2="31.14" y2="25.5" />
                <polygon class="cls-3" points="29.16 28.41 40 25.5 29.16 22.59 29.16 28.41" />
                <line class="cls-1" x1="100" y1="25.5" x2="191.14" y2="25.5" />
                <polygon class="cls-3" points="189.16 28.41 200 25.5 189.16 22.59 189.16 28.41" />
                <rect class="cls-4" x="120" y="10.5" width="60" height="30" rx="5" />
                <text class="cls-2" transform="translate(126 30.69)">子表达式</text>
            </svg>
        </li>
        <li>
            <p>对于单个字母a,构造这样一个NFA</p>
            <svg data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 195.5 51" style="height: 60px;">
                <defs>

                </defs>
                <style>
                    @scope {
                        .cls-1 {
                            fill: none;
                            stroke: #231815;
                            stroke-miterlimit: 10;
                        }

                        .cls-2 {
                            font-size: 12px;
                            font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;
                        }

                        .cls-2,
                        .cls-3 {
                            fill: #231815;
                        }
                    }
                </style>
                <circle class="cls-1" cx="70" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(60.11 29.26)">start</text>
                <circle class="cls-1" cx="170" cy="25.5" r="25" />
                <circle class="cls-1" cx="170" cy="25.5" r="23" />
                <text class="cls-2" transform="translate(161.17 29.26)">end</text>
                <line class="cls-1" y1="25.5" x2="31.14" y2="25.5" />
                <polygon class="cls-3" points="29.16 28.41 40 25.5 29.16 22.59 29.16 28.41" />
                <line class="cls-1" x1="100" y1="25.5" x2="131.14" y2="25.5" />
                <polygon class="cls-3" points="129.16 28.41 140 25.5 129.16 22.59 129.16 28.41" />
                <text class="cls-2" transform="translate(117.5 17.45)">a</text>
            </svg>
        </li>
        <li>
            <p>子表达式α连接β时,构造这样一个NFA</p>
            <svg data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 515.5 51" style="height: 60px;">
                <defs>

                </defs>
                <style>
                    @scope {
                        .cls-1 {
                            fill: none;
                        }

                        .cls-1,
                        .cls-4 {
                            stroke: #231815;
                            stroke-miterlimit: 10;
                        }

                        .cls-2,
                        .cls-5 {
                            font-size: 12px;
                        }

                        .cls-2,
                        .cls-3,
                        .cls-5 {
                            fill: #231815;
                        }

                        .cls-2 {
                            font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;
                        }

                        .cls-4 {
                            fill: #fff;
                        }

                        .cls-5 {
                            font-family: DengXian;
                        }
                    }
                </style>
                <circle class="cls-1" cx="70" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(60.11 29.26)">start</text>
                <circle class="cls-1" cx="230" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(221.17 29.26)">end</text>
                <line class="cls-1" y1="25.5" x2="31.14" y2="25.5" />
                <polygon class="cls-3" points="29.16 28.41 40 25.5 29.16 22.59 29.16 28.41" />
                <line class="cls-1" x1="100" y1="25.5" x2="191.14" y2="25.5" />
                <polygon class="cls-3" points="189.16 28.41 200 25.5 189.16 22.59 189.16 28.41" />
                <rect class="cls-4" x="120" y="10.5" width="60" height="30" rx="5" />
                <text class="cls-5" transform="translate(122.42 28.85)">子表达式α</text>
                <circle class="cls-1" cx="330" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(320.11 29.26)">start</text>
                <circle class="cls-1" cx="490" cy="25.5" r="25" />
                <circle class="cls-1" cx="490" cy="25.5" r="23" />
                <text class="cls-2" transform="translate(481.17 29.26)">end</text>
                <line class="cls-1" x1="260" y1="25.5" x2="291.14" y2="25.5" />
                <polygon class="cls-3" points="289.16 28.41 300 25.5 289.16 22.59 289.16 28.41" />
                <line class="cls-1" x1="360" y1="25.5" x2="451.14" y2="25.5" />
                <polygon class="cls-3" points="449.16 28.41 460 25.5 449.16 22.59 449.16 28.41" />
                <rect class="cls-4" x="380" y="10.5" width="60" height="30" rx="5" />
                <text class="cls-5" transform="translate(382.42 28.85)">子表达式β</text>
                <text class="cls-5" transform="translate(277.37 17.46)">ε</text>
            </svg>
            <p>我们把表达式α的结束状态和表达式β的开始状态用一条ε边连接得到一个新的状态机,然后以α的开始状态作为新状态机的开始,以β的结束状态作为新状态机的结束状态。</p>
        </li>
        <li>
            <p>两个子表达式α、β并联的时候(α|β),构造这样一个NFA</p>
            <svg style="height: 150px;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 486.31 106">
                <defs>

                </defs>
                <style>
                    @scope {

                        .cls-1,
                        .cls-3 {
                            fill: none;
                        }

                        .cls-1,
                        .cls-7 {
                            stroke: #231815;
                        }

                        .cls-1,
                        .cls-3,
                        .cls-7 {
                            stroke-miterlimit: 10;
                        }

                        .cls-2,
                        .cls-4,
                        .cls-8,
                        .cls-9 {
                            font-size: 12px;
                        }

                        .cls-2,
                        .cls-6,
                        .cls-8 {
                            fill: #231815;
                        }

                        .cls-2,
                        .cls-4 {
                            font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;
                        }

                        .cls-3 {
                            stroke: #e60012;
                        }

                        .cls-4,
                        .cls-5,
                        .cls-9 {
                            fill: #e60012;
                        }

                        .cls-7 {
                            fill: #fff;
                        }

                        .cls-8,
                        .cls-9 {
                            font-family: DengXian;
                        }
                    }
                </style>
                <circle class="cls-1" cx="182.8" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(172.91 29.26)">start</text>
                <circle class="cls-3" cx="70" cy="53" r="25" />
                <text class="cls-4" transform="translate(60.11 56.76)">start</text>
                <circle class="cls-1" cx="342.8" cy="25.5" r="25" />
                <text class="cls-2" transform="translate(333.98 29.26)">end</text>
                <line class="cls-3" x1="98.03" y1="48" x2="144.61" y2="28.87" />
                <polygon class="cls-5" points="143.88 32.31 152.8 25.5 141.67 26.93 143.88 32.31" />
                <line class="cls-1" x1="212.8" y1="25.5" x2="303.94" y2="25.5" />
                <polygon class="cls-6" points="301.96 28.41 312.8 25.5 301.96 22.59 301.96 28.41" />
                <rect class="cls-7" x="232.8" y="10.5" width="60" height="30" rx="5" />
                <text class="cls-8" transform="translate(235.22 28.85)">子表达式α</text>
                <line class="cls-3" x1="372.8" y1="25.5" x2="419.29" y2="44.63" />
                <polygon class="cls-5" points="416.35 46.56 427.48 48 418.56 41.19 416.35 46.56" />
                <line class="cls-3" y1="53" x2="31.14" y2="53" />
                <polygon class="cls-5" points="29.16 55.91 40 53 29.16 50.09 29.16 55.91" />
                <text class="cls-9" transform="translate(397.51 32.08)">ε</text>
                <text class="cls-9" transform="translate(122.79 32.08)">ε</text>
                <text class="cls-9" transform="translate(122.79 64.58)">ε</text>
                <circle class="cls-1" cx="182.8" cy="80.5" r="25" />
                <text class="cls-2" transform="translate(172.91 84.26)">start</text>
                <circle class="cls-1" cx="342.8" cy="80.5" r="25" />
                <text class="cls-2" transform="translate(333.98 84.26)">end</text>
                <circle class="cls-3" cx="460.81" cy="53" r="25" />
                <circle class="cls-3" cx="460.81" cy="53" r="23" />
                <text class="cls-4" transform="translate(451.99 56.76)">end</text>
                <line class="cls-3" x1="98.03" y1="58" x2="144.61" y2="77.13" />
                <polygon class="cls-5" points="141.67 79.07 152.8 80.5 143.88 73.69 141.67 79.07" />
                <line class="cls-1" x1="212.8" y1="80.5" x2="303.94" y2="80.5" />
                <polygon class="cls-6" points="301.96 83.41 312.8 80.5 301.96 77.59 301.96 83.41" />
                <rect class="cls-7" x="232.8" y="65.5" width="60" height="30" rx="5" />
                <text class="cls-8" transform="translate(235.22 83.85)">子表达式α</text>
                <line class="cls-3" x1="372.8" y1="80.5" x2="419.29" y2="61.37" />
                <polygon class="cls-5" points="418.56 64.81 427.48 58 416.35 59.44 418.56 64.81" />
                <text class="cls-9" transform="translate(397.51 64.58)">ε</text>
            </svg>
            <p>我们创建了一个新的start状态和end状态作为新状态机的开始、结束状态(红色),然后从新start创建两条ε边,分别连接到原来子串的start状态。从原来两个子串的end状态各创建一条ε边连接到新end状态
            </p>
        </li>
        <li>
            <p>求子表达式α克林闭包(α*)的时候,构造这样一个NFA</p>
            <svg style="height: 300px;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 455.5 208.9">
                <defs>

                </defs>
                <style>
                    @scope {

                        .cls-1,
                        .cls-3 {
                            fill: none;
                        }

                        .cls-1,
                        .cls-6 {
                            stroke: #231815;
                        }

                        .cls-1,
                        .cls-3,
                        .cls-6 {
                            stroke-miterlimit: 10;
                        }

                        .cls-2,
                        .cls-4,
                        .cls-7,
                        .cls-9 {
                            isolation: isolate;
                            font-size: 12px;
                        }

                        .cls-2,
                        .cls-5,
                        .cls-7 {
                            fill: #231815;
                        }

                        .cls-2,
                        .cls-4 {
                            font-family: ArialMT, Arial;
                        }

                        .cls-3 {
                            stroke: #d71718;
                        }

                        .cls-4,
                        .cls-8,
                        .cls-9 {
                            fill: #d71718;
                        }

                        .cls-6 {
                            fill: #fff;
                        }

                        .cls-7,
                        .cls-9 {
                            font-family: DengXian;
                        }
                    }
                </style>
                <circle class="cls-1" cx="170" cy="87.97" r="25" />
                <text class="cls-2" transform="translate(160.11 91.72)">start</text>
                <circle class="cls-3" cx="70" cy="87.97" r="25" />
                <text class="cls-4" transform="translate(60.11 91.72)">start</text>
                <circle class="cls-1" cx="330" cy="87.97" r="25" />
                <text class="cls-2" transform="translate(321.17 91.72)">end</text>
                <line class="cls-1" x1="200" y1="87.97" x2="291.14" y2="87.97" />
                <polygon class="cls-5" points="289.16 90.87 300 87.97 289.16 85.06 289.16 90.87" />
                <rect class="cls-6" x="220" y="72.97" width="60" height="30" rx="5" />
                <text class="cls-7" transform="translate(222.42 91.3)">子表达式α</text>
                <line class="cls-3" y1="87.97" x2="31.14" y2="87.97" />
                <polygon class="cls-8" points="29.16 90.87 40 87.97 29.16 85.06 29.16 90.87" />
                <line class="cls-3" x1="100" y1="87.97" x2="131.14" y2="87.97" />
                <polygon class="cls-8" points="129.16 90.87 140 87.97 129.16 85.06 129.16 90.87" />
                <line class="cls-3" x1="360" y1="87.97" x2="391.14" y2="87.97" />
                <polygon class="cls-8" points="389.16 90.87 400 87.97 389.16 85.06 389.16 90.87" />
                <text class="cls-9" transform="translate(377.37 79.93)">ε</text>
                <text class="cls-9" transform="translate(117.37 79.93)">ε</text>
                <text class="cls-9" transform="translate(244.66 205.86)">ε</text>
                <text class="cls-9" transform="translate(248.14 9.7)">ε</text>
                <circle class="cls-3" cx="430" cy="87.97" r="25" />
                <circle class="cls-3" cx="430" cy="87.97" r="23" />
                <text class="cls-4" transform="translate(421.17 91.72)">end</text>
                <path class="cls-3" d="M298.61,170.13c68.28,95.2,279.29,97.53,354.58,7"
                    transform="translate(-228.61 -52.16)" />
                <polygon class="cls-8" points="425.6 128.29 430 117.97 421.03 124.71 425.6 128.29" />
                <path class="cls-3" d="M558.61,110.13c0-50.56-142.12-53.47-158.47-8.73"
                    transform="translate(-228.61 -52.16)" />
                <polygon class="cls-8" points="169.22 46.77 170 57.97 174.92 47.88 169.22 46.77" />
            </svg>
            <p>
                我们创建了一个新的start状态和end状态作为新状态机的开始、结束状态(红色),然后从新start创建两条ε边,分别连接到原子串的start和新的end状态。从原子串的end状态创建两条ε边,分别连接到原来子串的start状态和新end状态
            </p>
        </li>
    </ol>
    <p>通过上述几种基本的正则规则,我们可以实现一些扩展正则功能,比如"a+bc"这个正则表达式识别的是"以一个或者多个a开头,后面再连接bc两个字母",我们可以用"aa*bc"这个基本正则表达式描述</p>
    <h2>DFA</h2>
    <p>NFA在运行的时候,我们需要不断的计算闭包,这个过程比较消耗内存和CPU,看上面demo中的NFA运行示意图,我们进入start状态或者输入一个字母a之后,还得不断地搜索当前集合能通过ε边达到的新状态。存在一个简化NFA处理机制的方法,我们可以把NFA转换为DFA(deterministic
        finite automaton)。需要注意的是:<em>在NFA转换为DFA的过程中,其实并没有简化运算,但是在转换完成之后,速度将会直接起飞。</em></p>
    <p>当前NFA转换成DFA的过程也很简单,我们只要按照如下步骤循环进行就可以了</p>
    <div id="NFA-2-DFA">
        <template>
            <style>
            </style>
            <ol>
                <li>首先将closure(start)作为DFA的唯一状态,然后将closure(start)添加到待扫描状态集列表(new_stateset_list)中
                </li>
                <li>for(new_stateset_list中的每个状态集now)
                    <ol>
                        <li>for(now中所有非ε边,设该边为字母a)
                            <ol>
                                <li>将所有a指向的后继状态添加到next状态集中</li>
                                <li>检查clouser(next)是否已经存在于DFA中
                                    <ul>
                                        <li>如果closure(next)没有存在于DFA,则将closure(next)分别添加到DFA和待扫描状态集列表中。并在now创建一条边a指向closure(next)
                                        </li>
                                        <li>如果closure(next)已经存在于DFA,则直接now创建一条边a指向closure(next)</li>
                                    </ul>
                                </li>
                            </ol>
                        </li>
                    </ol>
                </li>
                <li>直到new_stateset_list没有任何新增状态集,程序结束</li>
            </ol>
            <p>将"a*b"对应的NFA转换成DFA的动画,点击下一步观看:<button id="next">下一步</button></p>
            <svg style="height: 600px;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 802.07 495.12">
                <g id="p_0_1" data-name="p 0 1">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="105" y1="102.24" x2="141.14"
                        y2="102.24" pathLength="100" />
                    <polygon points="139.16 105.14 150 102.24 139.16 99.33 139.16 105.14" />
                </g>
                <g id="p_1_2" data-name="p 1 2">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="210" y1="102.24" x2="246.14"
                        y2="102.24" pathLength="100" />
                    <polygon points="244.16 105.14 255 102.24 244.16 99.33 244.16 105.14" />
                </g>
                <g id="p_2_3" data-name="p 2 3">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="315" y1="102.24" x2="351.14"
                        y2="102.24" pathLength="100" />
                    <polygon points="349.16 105.14 360 102.24 349.16 99.33 349.16 105.14" />
                </g>
                <g id="p_3_4" data-name="p 3 4">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="420" y1="102.24" x2="456.14"
                        y2="102.24" pathLength="100" />
                    <polygon points="454.16 105.14 465 102.24 454.16 99.33 454.16 105.14" />
                </g>
                <g id="p_4_5" data-name="p 4 5">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="525" y1="102.24" x2="561.14"
                        y2="102.24" pathLength="100" />
                    <polygon points="559.16 105.14 570 102.24 559.16 99.33 559.16 105.14" />
                </g>
                <g id="p_2_1" data-name="p 2 1">
                    <path style="fill: none;stroke: #000;stroke-miterlimit: 10;"
                        d="M306.52,93.57c0-68.77-96.19-71.72-104.44-8.85" transform="translate(-21.52 -21.33)"
                        pathLength="100" />
                    <polygon points="177.87 61.22 180 72.24 183.66 61.63 177.87 61.22" />
                </g>
                <g id="p_0_3" data-name="p 0 3">
                    <path style="fill: none;stroke: #000;stroke-miterlimit: 10;" d="M96.52,153.57q153.5,74.3,307,3.78"
                        transform="translate(-21.52 -21.33)" pathLength="100" />
                    <polygon points="381.33 139.36 390 132.24 378.93 134.07 381.33 139.36" />
                </g>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(230 94.19)">a</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(544.48 94.19)">b</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(226.5 10.3)">ε</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(331.5 94.19)">ε</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(436.5 94.19)">ε</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(121.5 94.19)">ε</text>
                <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 12px;"
                    transform="translate(226.5 185.92)">ε</text>
                <g id="state0">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="75" cy="102.24" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(60.16 107.87)">start</text>
                </g>
                <g id="state1">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="180" cy="102.24" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(175.84 107.87)">1</text>
                </g>
                <g id="state2">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="285" cy="102.24" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(280.84 107.87)">2</text>
                </g>
                <g id="state3">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="390" cy="102.24" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(385.84 107.87)">3</text>
                </g>
                <g id="state4">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="495" cy="102.24" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(490.84 107.87)">4</text>
                </g>
                <g id="state5">
                    <path style="stroke-width:0;"
                        d="M621.52,102.07a21.5,21.5,0,1,1-21.5,21.5h0a21.52,21.52,0,0,1,21.5-21.5m0-1a22.5,22.5,0,1,0,22.5,22.5h0A22.5,22.5,0,0,0,621.52,101.07Z"
                        transform="translate(-21.52 -21.33)" />
                    <path style="stroke-width:0;"
                        d="M621.52,99.57a24,24,0,1,1-24,24,24,24,0,0,1,24-24m0-1a25,25,0,1,0,25,25A25,25,0,0,0,621.52,98.57Z"
                        transform="translate(-21.52 -21.33)" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(586.76 107.87)">end</text>
                </g>
                <g id="p_0_0" data-name="p 0 0">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" y1="102.24" x2="36.14" y2="102.24" />
                    <polygon points="34.16 105.14 45 102.24 34.16 99.33 34.16 105.14" />
                </g>
                <g id="closure_s" style="display: none;">
                    <ellipse style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="133.65" cy="370.26" rx="94.2"
                        ry="67.26" />
                    <g id="state0-2" data-name="state0">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="106.15" cy="342.76" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(91.31 348.39)">start</text>
                    </g>
                    <g id="state1-2" data-name="state1">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="161.15" cy="342.76" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(156.99 348.39)">1</text>
                    </g>
                    <g id="state3-2" data-name="state3">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="106.15" cy="397.76" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(101.99 403.39)">3</text>
                    </g>
                    <g id="state4-2" data-name="state4">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="161.15" cy="397.76" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(156.99 403.39)">4</text>
                    </g>
                </g>
                <g id="state2-2" data-name="state2" style="display: none;">
                    <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="312.74" cy="305.89" r="25" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(308.58 311.52)">2</text>
                </g>
                <g id="closure_1234" style="display: none;">
                    <g id="state1-3" data-name="state1">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="312.74" cy="250.89" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(308.58 256.52)">1</text>
                    </g>
                    <g id="state3-3" data-name="state3">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="367.74" cy="250.89" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(363.58 256.52)">3</text>
                    </g>
                    <g id="state4-3" data-name="state4">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="367.74" cy="305.89" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(363.58 311.52)">4</text>
                    </g>
                    <ellipse style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="340.24" cy="279.28" rx="74.18"
                        ry="66.56" />
                </g>
                <g id="state5-2" data-name="state5" style="display: none;">
                    <path
                        d="M351.28,459.73a21.5,21.5,0,1,1-21.5,21.5h0a21.52,21.52,0,0,1,21.5-21.5m0-1a22.5,22.5,0,1,0,22.5,22.5h0A22.5,22.5,0,0,0,351.28,458.73Z"
                        transform="translate(-21.52 -21.33)" />
                    <path
                        d="M351.28,457.23a24,24,0,1,1-24,24,24,24,0,0,1,24-24m0-1a25,25,0,1,0,25,25A25,25,0,0,0,351.28,456.23Z"
                        transform="translate(-21.52 -21.33)" />
                    <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                        transform="translate(316.51 465.53)">end</text>
                </g>
                <g id="closure_e" style="display: none;">
                    <ellipse style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="329.75" cy="459.9" rx="48.39"
                        ry="34.72" />
                </g>

                <g id="DFA_0_1" style="display: none;">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="215.75" y1="324.28" x2="254.37"
                        y2="303.48" />
                    <polygon points="254 306.98 262.17 299.28 251.24 301.86 254 306.98" />
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(236.46 303.01)">a</text>
                </g>
                <g id="DFA_0_2" style="display: none;">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="228.5" y1="403.61" x2="273.74"
                        y2="430.39" />
                    <polygon points="270.55 431.88 281.36 434.9 273.51 426.88 270.55 431.88" />
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(254.93 411.64)">b</text>
                </g>
                <g id="DFA_1_1" style="display: none;">
                    <path style="fill: none;stroke: #000;stroke-miterlimit: 10;"
                        d="M441.52,291.21c79-39.27,18.22-104.89-31.55-63.24" transform="translate(-21.52 -21.33)" />
                    <polygon points="388.02 203.25 382 212.72 391.95 207.53 388.02 203.25" />
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(458.05 201.96)">a</text>
                </g>
                <g id="DFA_1_2" style="display: none;">
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="336.3" y1="348.39" x2="332.1"
                        y2="410.2" />
                    <polygon points="329.34 408.03 331.5 419.04 335.13 408.42 329.34 408.03" />
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(345.22 386.39)">b</text>
                </g>
                <g id="DFA" style="display: none;">
                    <g id="DFA_S0">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="571.49" cy="325.47" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(556.65 331.1)">start</text>
                    </g>
                    <g id="DFA_S1">
                        <circle style="fill: none;stroke: #000;stroke-miterlimit: 10;" cx="739.89" cy="289.48" r="25" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(735.73 295.11)">1</text>
                    </g>
                    <g id="DFA_S2">
                        <path
                            d="M694.53,444.09a21.5,21.5,0,1,1-21.5,21.5h0a21.52,21.52,0,0,1,21.5-21.5m0-1a22.5,22.5,0,1,0,22.5,22.5h0A22.5,22.5,0,0,0,694.53,443.09Z"
                            transform="translate(-21.52 -21.33)" />
                        <path
                            d="M694.53,441.59a24,24,0,1,1-24,24,24,24,0,0,1,24-24m0-1a25,25,0,1,0,25,25A25,25,0,0,0,694.53,440.59Z"
                            transform="translate(-21.52 -21.33)" />
                        <text style="isolation: isolate;font-family: ArialMT, Arial;font-size: 18px;"
                            transform="translate(659.77 449.88)">end</text>
                    </g>
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="601.63" y1="317.76" x2="697.9"
                        y2="291.79" />
                    <polygon points="696.74 295.11 706.45 289.48 695.23 289.5 696.74 295.11" />
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="596.39" y1="348.39" x2="650.46"
                        y2="412.48" />
                    <polygon points="646.96 412.84 656.17 419.25 651.4 409.09 646.96 412.84" />
                    <line style="fill: none;stroke: #000;stroke-miterlimit: 10;" x1="729.96" y1="318.5" x2="686.8"
                        y2="408.08" />
                    <polygon points="685.04 405.04 682.95 416.06 690.27 407.56 685.04 405.04" />
                    <path style="fill: none;stroke: #000;stroke-miterlimit: 10;"
                        d="M794.94,308.37c31.58-14,23-50.75-10.68-33.06" transform="translate(-21.52 -21.33)" />
                    <polygon points="762.98 250.54 755.17 258.6 765.97 255.53 762.98 250.54" />
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(656.07 295.11)">a</text>
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(611.76 390.5)">b</text>
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(714.89 367.28)">b</text>
                    <text style="font-size: 12px;font-family: AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std;"
                        transform="translate(797.06 254.35)">a</text>
                </g>
            </svg>
        </template>
    </div>
    <p>可以看到,将NFA转换为DFA之后,大幅度的减少了状态数量,而且不再有任何ε边。并且NFA存在这样一种可能,从某个状态s出发,可能有两条一样的字母a边跳转到不同后继状态n1和n2。</p>
    <svg style="height: 200px;" data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 156 134.77">
        <defs>

        </defs>
        <style>
            @scope {

                .cls-1,
                .cls-3 {
                    isolation: isolate;
                    font-family: ArialMT, Arial;
                }

                .cls-1 {
                    font-size: 12px;
                }

                .cls-2 {
                    fill: none;
                    stroke: #000;
                    stroke-miterlimit: 10;
                }

                .cls-3 {
                    font-size: 18px;
                }
            }
        </style>
        <text class="cls-1" transform="translate(73.85 36.48)">a</text><text class="cls-1"
            transform="translate(74.28 86.95)">a</text>
        <g>
            <circle class="cls-2" cx="25.5" cy="67.39" r="25" /><text class="cls-3"
                transform="translate(21.34 73.02)">1</text>
        </g>
        <g>
            <circle class="cls-2" cx="130.5" cy="25.5" r="25" /><text class="cls-3"
                transform="translate(126.34 31.13)">2</text>
        </g>
        <g>
            <circle class="cls-2" cx="130.5" cy="109.27" r="25" /><text class="cls-3"
                transform="translate(126.34 114.9)">3</text>
        </g>
        <line class="cls-2" x1="51.53" y1="52.02" x2="92.37" y2="34.61" />
        <polygon points="91.69 38.05 100.52 31.13 89.41 32.71 91.69 38.05" />
        <line class="cls-2" x1="52.32" y1="79.79" x2="93.24" y2="98.31" />
        <polygon points="90.24 100.14 101.31 101.96 92.63 94.84 90.24 100.14" />
    </svg>
    <p>其实之前的例子中也出现过同一个状态有多个不同的ε边指向不同的目标状态,ε边和字母a是类似的,只不过ε多了一个"允许无条件跳转"的语义</p>
    <h2>词法分析小结:</h2>
    <p>一个正则引擎不一定是用NFA或者DFA运行的,因为DFA速度快,消耗内存小,但是会丢弃一些信息(比如分组信息),所以目前主流的正则实现都是采用NFA方法工作。NFA在匹配的时候必须走所有的可能路径(也可以把这个理解为一种回溯),所以很多NFA在实现的时候当遇到了end状态就直接结束,而DFA则没有这种顾虑,所以可以用这种方法大概的测试一下当前工具使用NFA还是DFA。用"nfa|nfa
        not"这个正则表达式去测试串"nfa not",一般的NFA引擎会解析到nfa就结束。
    </p>
    <p>比如在浏览器控制台执行这行代码,输入如下</p>
    > /nfa|nfa not/.exec('nfa not')[0]<br />
    > 'nfa'
    <p>至此我们已经知道正则引擎是怎么工作的了,可以很轻松的根据已有正则编写出一个状态机运行。但是还有一个问题,正则表达式的表达能力是3型文法,但是正则表达本身是一个2型文法才能描述的语言。所以后续我们将会学习编译器前端的灵魂部分:文法分析
    </p>
    <h1>文法分析</h1>
    <p>第二个坑,龙书对first集计算方法没有讲的很清楚。还有LR(1)后面为什么不用求follow集,因为后面一个一定是非终结符</p>
    <p>文法分析是编译器前端最核心的功能,通常会把编译器的词法分析模块叫做lex(Lexical Analyzer
        Generator),文法分析模块叫做parser,lex将源码变成一个个的token,parser把这些token变成一个AST(abstract syntax
        tree)。在这里我们只讲解2-型文法(上下文无关分发)的parser工作原理</p>
    <h2>first集</h2>
    <p>first(α)表示串α的首个非终结符的集合,比如first(abc)={a},一旦给定一个文法G,则我们就能计算出任何一个串的first集(这个串的所有token必须是文法范文内的终结符、非终结符或者ε),first集的规则如下:
    </p>
    <em>这里和龙书的定义稍微有一点点差别,是按照我的理解对龙书的定义进行了一些拙劣的加工</em>
    <p>计算first(α),其中<math>
            <mi>α</mi>
            <mo>=</mo>
            <msub>
                <mi>X</mi>
                <mn>1</mn>
            </msub>
            <msub>
                <mi>X</mi>
                <mn>2</mn>
            </msub>
            <mi>...</mi>
            <msub>
                <mi>X</mi>
                <mn>n</mn>
            </msub>
        </math>,我们先创建一个空集合作为结果集:ret={},然后从n=1开始依次处理每个符号,假设当前处理的符号下标为i</p>
    <ol>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个非ε终结符,则将<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>添加到ret,并终止计算</li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是ε,进行如下检查
            <ul>
                <li>i等于n(也就是最后一个符号还是ε),将ε添加到ret</li>
                <li>i不等于n(还没到最后一个符号),不做任何动作</li>
            </ul>
        </li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个终结符,则对所有以<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>开头的产生式<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>1</mi>
                </msub>
            </math>一直到<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>h</mi>
                </msub>
            </math>计算<math>
                <mi>first</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>,我们把所有的计算结果合并到一个临时集合tmp中,然后检查tmp中是否有ε
            <ul>
                <li>没有ε,则将temp合并到ret中,并终止计算</li>
                <li>有ε,则进行如下检查
                    <ul>
                        <li>i等于n(也就是最后一个符号还包含ε),把temp合并到ret中(此时tmp包含了ε)</li>
                        <li>i不等于n(还没到最后一个符号),从tmp移除ε之后再合并到ret中</li>
                    </ul>
                </li>
            </ul>
        </li>
    </ol>
    <p>假设我们有如下的文法:</p>
    <ol>
        <li><math>
                <mi>S</mi>
                <mo>→</mo>
                <mi>E</mi>
            </math></li>
        <li><math>
                <mi>E</mi>
                <mo>→</mo>
                <mi>a</mi>
            </math></li>
        <li><math>
                <mi>E</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>b</mi>
            </math></li>
        <li><math>
                <mi>F</mi>
                <mo>→</mo>
                <mi>ε</mi>
            </math></li>
    </ol>
    <p>则first(S)={a,b}</p>
    <p>龙书的算法大致如上,但是有一点没有说的很清楚,所以我特别补充一下:<em class="stress">在计算first的过程中,遇到递归产生式的处理方法。</em>假设我们有如下文法:
    </p>
    <ol>
        <li><math>
                <mi>S</mi>
                <mo>→</mo>
                <mi>A</mi>
                <mi>B</mi>
            </math></li>
        <li><math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>S</mi>
                <mi>a</mi>
            </math></li>
        <li><math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>ε</mi>
            </math></li>
        <li><math>
                <mi>B</mi>
                <mo>→</mo>
                <mi>S</mi>
                <mi>b</mi>
            </math></li>
    </ol>
    <p>我们在计算first(S)的时候,需要求first(AB),因为<math>
            <mi>A</mi>
            <mo>→</mo>
            <mi>S</mi>
            <mi>a</mi>
        </math>,如果我们单纯的继续展开S,就会进入无限展开,永远都得不到结果。实际上龙书默认我们已经懂了,但是可能部分读者并没有懂的一个知识点:</p>
    <P>(PS:这个定理不是龙书说的,是我编出来的)我把这个称为<span
            class="emphasize">直接推导定理</span>。先定义一下直接推导路径:<em>在符号替换流程中,每个产生式只被使用一次的替换路径叫做直接推导路径。</em>如下的两种推导路径:
    </p>
    <ol>
        <li><math>
                <mi>S</mi>
                <mover>
                    <mo>→</mo>
                    <mo>产生式1替换S</mo>
                </mover>
                <mrow>
                    <mi>A</mi>
                    <mi>B</mi>
                </mrow>
                <mover>
                    <mo>→</mo>
                    <mo>产生式2替换A</mo>
                </mover>
                <mrow>
                    <mi>S</mi>
                    <mi>a</mi>
                    <mi>B</mi>
                </mrow>
                <mover>
                    <mo>→</mo>
                    <mo>产生式4替换B</mo>
                </mover>
                <mrow>
                    <mi>S</mi>
                    <mi>a</mi>
                    <mi>S</mi>
                    <mi>b</mi>
                </mrow>
            </math></li>
        <li><math>
                <mi>S</mi>
                <mover>
                    <mo>→</mo>
                    <mo>产生式1替换S</mo>
                </mover>
                <mrow>
                    <mi>A</mi>
                    <mi>B</mi>
                </mrow>
                <mover>
                    <mo>→</mo>
                    <mo>产生式2替换A</mo>
                </mover>
                <mrow>
                    <mi>S</mi>
                    <mi>a</mi>
                    <mi>B</mi>
                </mrow>
                <mover>
                    <mo>→</mo>
                    <mo>产生式1替换S</mo>
                </mover>
                <mrow>
                    <mi>A</mi>
                    <mi>B</mi>
                    <mi>a</mi>
                    <mi>B</mi>
                </mrow>
            </math></li>
    </ol>
    <p>第一种推导叫做直接推导,第二中就叫做递归推导,因为之前已经用过一次产生式1了,后面的替换中,我们又用产生式1替换,这样可以无穷无止地替换下去。</p>
    <p>知道了直接推导和递归推导的概念之后,就可以说一下直接推导定理了:</p>
    <ul>
        <li class="emphasize">递归推导对first(X)不会对结果产生任何影响</li>
    </ul>
    <p>所以为了解决递归求解first的问题,我们需要先定义一个辅助函数have_epsilon(α),这个函数用于判断,串α的first集合是否包含ε,计算步骤和first及其相似,但是为通用的first函数提供了基础。计算流程如下:
    </p>
    <p>计算have_epsilon(α),其中<math>
            <mi>α</mi>
            <mo>=</mo>
            <msub>
                <mi>X</mi>
                <mn>1</mn>
            </msub>
            <msub>
                <mi>X</mi>
                <mn>2</mn>
            </msub>
            <mi>...</mi>
            <msub>
                <mi>X</mi>
                <mn>n</mn>
            </msub>
        </math>,我们从n=1开始依次处理每个符号,假设当前处理的符号下标为i</p>
    <ol>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是ε,则进行如下判断:
            <ul>
                <li>i等于n(也就是最后一个符号还是ε),返回true</li>
                <li>i不等于n(没有到最后一个符号),不做任何动作,进行下一个符号的处理</li>
            </ul>
        </li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个终结符,不做任何动作,进行下一个符号的处理</li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个终结符,则对所有以<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>开头的产生式<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>1</mi>
                </msub>
            </math>一直到<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>h</mi>
                </msub>
            </math><em>(如果<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>对应的产生式已经被展开过,则我们应该跳过<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>,否则我们要标记<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>对应的产生式被展开①)</em>,计算<math>
                <mi>have_epsilon</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>,并且我们对每个
            <math>
                <mi>have_epsilon</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>的返回值做判断<em>(在递归调用之后,也就是得到<math>
                    <mi>have_epsilon</mi>
                    <mo>(</mo>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                    <mo>)</mo>
                </math>的返回值之后,我们要移除①处做的标记)</em>
            <ul>
                <li>如果
                    <math>
                        <mi>have_epsilon</mi>
                        <mo>(</mo>
                        <msub>
                            <mi>β</mi>
                            <mi>j</mi>
                        </msub>
                        <mo>)</mo>
                        <mo>==</mo>
                        <mn>true</mn>
                    </math>
                    ,则又进行如下检查
                    <ul>
                        <li>i等于n(也就是最后一个符号还是ε),返回true</li>
                        <li>i不等于n(没有到最后一个符号),不做任何动作,进行下一个符号的处理(此时已经在内层循环中了,还在处理 <math>
                                <mi>have_epsilon</mi>
                                <mo>(</mo>
                                <msub>
                                    <mi>β</mi>
                                    <mi>j</mi>
                                </msub>
                                <mo>)</mo>
                            </math>呢)</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>如果处理到i=n还没有得到true,则直接返回false</li>
    </ol>
    <p>有了have_epsilon,我们就可以对first流程做一些轻微的改动,使他能完全处理有递归的文法,改进后的first计算流程如下:</p>
    <ol>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个非ε终结符,则将<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>添加到ret,并终止计算</li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是ε,进行如下检查
            <ul>
                <li>i等于n(也就是最后一个符号还是ε),将ε添加到ret</li>
                <li>i不等于n(还没到最后一个符号),不做任何动作</li>
            </ul>
        </li>
        <li>如果<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>是一个终结符,则对所有以<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
            </math>开头的产生式<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>1</mi>
                </msub>
            </math>一直到<math>
                <msub>
                    <mi>X</mi>
                    <mi>i</mi>
                </msub>
                <mo>→</mo>
                <msub>
                    <mi>β</mi>
                    <mi>h</mi>
                </msub>
            </math><em>(如果<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>对应的产生式已经被展开过,则我们应该跳过<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>,否则我们要标记<math>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                </math>对应的产生式被展开①<span class="stress"> 特别提醒:这里的标记和have_epsilon是两个不同的标记</span>)</em>,先计算<math>
                <mi>have_epsilon</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>,然后计算
            <math>
                <mi>first</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>,我们把所有的计算结果移除掉ε后合并到ret中,<em>(在递归调用之后,也就是得到<math>
                    <mi>first</mi>
                    <mo>(</mo>
                    <msub>
                        <mi>β</mi>
                        <mi>j</mi>
                    </msub>
                    <mo>)</mo>
                </math>的返回值之后,我们要移除①处做的标记)</em>,然后检查<math>
                <mi>have_epsilon</mi>
                <mo>(</mo>
                <msub>
                    <mi>β</mi>
                    <mi>j</mi>
                </msub>
                <mo>)</mo>
            </math>的计算结果
            <ul>
                <li>如果结果为false,则终止计算</li>
                <li>如果结果为true,则进行如下检查
                    <ul>
                        <li>i等于n(也就是最后一个符号还包含ε),把ε添加到ret中</li>
                        <li>i不等于n(还没到最后一个符号),不做任何动作,进行下一个符号的处理(此时已经在内层循环中了,还在处理 <math>
                                <mi>have_epsilon</mi>
                                <mo>(</mo>
                                <msub>
                                    <mi>β</mi>
                                    <mi>j</mi>
                                </msub>
                                <mo>)</mo>
                            </math>呢)</li>
                </li>
            </ul>
        </li>
        </ul>
        </li>
    </ol>
    <p>至此,first集的计算方法已经完整了</p>
    <h2>follow集</h2>
    <p>相对于first集,follow集是指一个<em>非终结符</em>的后继符号,比如下面的文法:</p>
    <ol>
        <li><math>
                <mi>S</mi>
                <mo>→</mo>
                <mi>A</mi>
                <mi>B</mi>
            </math></li>
        <li><math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>S</mi>
                <mi>a</mi>
            </math></li>
        <li><math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>ε</mi>
            </math></li>
        <li><math>
                <mi>B</mi>
                <mo>→</mo>
                <mi>S</mi>
                <mi>b</mi>
            </math></li>
    </ol>
    <p>我们可以计算follow(S),follow(A),follow(B),但是如果计算follow(a)或者follow(ε)是没什么意义的。对于follow集,我们可以应用下面的程序进行计算</p>
    <ol>
        <li>follow(S)={$},这里的S指整个文法的起始符号,$是一个特殊定义的终结符,表示输入源码的结束标志,这里应该很好理解,整个文法已经解析完成,此时应该接受一个结束标记</li>
        <li>如果存在一个产生式A→αBβ,那么FIRST(β)中除ε之外的所有符号都在follow(B)中。也就是我们扫描所有的产生式,如果非终结符B不在产生式的末尾,我们就从B后面截断这个产生式,然后计算裁剪出来符号串的first集并移除ε后添加到follow集。接下来我们检查这个first是否包含了ε
            <ul>
                <li>如果包含ε,则计算follow(A),并且将follow(A)的结果添加到follow(B)中</li>
            </ul>
        </li>
        <li>如果存在一个产生式A→αB,那么follow(A)中的所有符号都在follow(B)中</li>
    </ol>
    <em>如果出现右递归,即<math>
            <mi>A</mi>
            <mo>→</mo>
            <mi>α</mi>
            <mi>A</mi>
        </math>(或者间接右递归),我们采用和计算first集类似的策略,直接避免这个产生式的展开即可</em>
    <P>如果我们仔细观察上述规则2的ε检查和规则3,可以发现他们说的是同一件事情<em>first()={ε} (这里计算的是一个空串first集)</em></P>
    <h2>左递归</h2>
    <p>如果一个文法中有产生式如同
        <math>
            <mi>A</mi>
            <mover>
                <mo>→</mo>
                <mo>+</mo>
            </mover>
            <mi>A</mi>
            <mi>α</mi>
        </math>,则我们称这个文法是左递归的(这个+号表示直接推导或者间接推导),LL(K)文法分析器无法处理左递归文法,所以我们需要消除左递归。
    </p>
    <h3>左递归的消除</h3>
    <p>假设我们有如下产生式导致了左递归(<em>需要注意的是,一个有意义的文法,如果某个非终结符出现了左递归,则这个非终结符一定至少有一条产生式的最左边是非左递归的,否则一个悬空的形如 <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>A</mi>
                <mi>α</mi>
            </math>的产生式会导致无限展开,永远无法结束,这就是我总结的直接推导定理的依据,也就是这个递归产生式的头部一定是由其他产生式规约而成,不允许自身规约。右递归同理</em>)</p>
    <ol>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>A</mi>
                <mi>α</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>A</mi>
                <mi>β</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>γ</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>θ</mi>
            </math>
        </li>
    </ol>
    <p>基于上面理论,我们进行如下改造:</p>
    <ol>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>γ</mi>
                <mi>A'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>θ</mi>
                <mi>A'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A'</mi>
                <mo>→</mo>
                <mi>α</mi>
                <mi>A'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A'</mi>
                <mo>→</mo>
                <mi>β</mi>
                <mi>A'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>A'</mi>
                <mo>→</mo>
                <mi>ε</mi>
            </math>
        </li>
    </ol>
    <p>改造之后的文法和之前的文法表达能力相同,并且我们把左递归变成了右递归。</p>
    <h2>二义性</h2>
    <p>如果一个输入串可以根据我们的文法生成两颗不同的语法树,就说明这个文法是二义性的。所以我们在设计文法的时候就应该避免二义性。下面举些例子说明一下二义性文法</p>
    <ol>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mi>E</mi>
                <mo>+</mo>
                <mi>E</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mo>id</mo>
            </math>
            <em>这里的id表示一个终结符,类比于java中的一个变量</em>
        </li>
    </ol>
    <p>那么对于输入a+b+c,可以得到两颗不同的语法树</p>
    <svg data-name="图层 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 210.75 100.07" style="height: 300px;"><text
            transform="translate(23.02 90.63)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">a</text><text
            transform="translate(131.62 68.67)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">a</text><text
            transform="translate(63.13 90.63)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">b</text><text
            transform="translate(162.53 93.03)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">b</text><text
            transform="translate(22.53 70.03)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(42.65 47.5)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(66.52 20.06)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(87.83 47.5)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(174.39 49.01)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(62.77 70.03)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text><text
            transform="translate(89.46 70.03)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">c</text><text
            transform="translate(186.19 92.14)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">c</text>
        <line x1="25.52" y1="73.07" x2="25.52" y2="80.07"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="46.07" y1="52.2" x2="46.07" y2="59.2"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="66.14" y1="73.07" x2="66.14" y2="80.07"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" /><text
            transform="translate(131.24 50.7)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text>
        <line x1="134.62" y1="53.74" x2="134.62" y2="60.74"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" /><text
            transform="translate(160.84 69.45)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text>
        <line x1="164.22" y1="72.5" x2="164.22" y2="79.5"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" /><text
            transform="translate(185.69 70.05)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text>
        <line x1="189.07" y1="73.1" x2="189.07" y2="80.1"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" /><text
            transform="translate(42.4 68.64)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">+</text><text
            transform="translate(66.9 45.86)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">+</text><text
            transform="translate(150.7 49.9)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">+</text><text
            transform="translate(173.71 68.67)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">+</text>
        <line x1="35.75" y1="51" x2="29.84" y2="58"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="53.92" y1="27.14" x2="48" y2="34.09"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="70.2" y1="25.63" x2="70.4" y2="34.76"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="91.66" y1="49.94" x2="91.86" y2="59.06"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="52.61" y1="50.9" x2="60.47" y2="57.9"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="177.46" y1="51.57" x2="177.46" y2="58.57"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="167.14" y1="50.37" x2="161.23" y2="57.37"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="184" y1="50.27" x2="191.86" y2="57.27"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="83.9" y1="27.55" x2="91.76" y2="36.28"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" /><text
            transform="translate(153.93 21.41)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">E</text>
        <line x1="141.32" y1="28.5" x2="135.41" y2="35.44"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="157.61" y1="26.99" x2="157.81" y2="36.11"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <line x1="171.31" y1="28.91" x2="179.16" y2="37.64"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.25px" />
        <rect x="0.25" y="0.25" width="99.57" height="99.57"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.5px" />
        <rect x="118.46" y="0.25" width="92.03" height="99.57"
            style="fill:none;stroke:#231815;stroke-miterlimit:10;stroke-width:0.5px" /><text
            transform="translate(3.67 13.9)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">语法树1</text><text
            transform="translate(167.28 12.55)"
            style="font-size:12px;fill:#231815;font-family:AdobeSongStd-Light-GBpc-EUC-H, Adobe Song Std">语法树2</text>
    </svg>
    <p>或者对于下面这种文法,有个经典的if-else二义性</p>
    <ol>
        <li>
            <math>
                <mi>stmt</mi>
                <mo>→</mo>
                <mi>if</mi>
                <mo>(</mo>
                <mi>exp</mi>
                <mo>)</mo>
                <mi>stmt</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>stmt</mi>
                <mo>→</mo>
                <mi>if</mi>
                <mo>(</mo>
                <mi>exp</mi>
                <mo>)</mo>
                <mi>stmt</mi>
                <mo>else</mo>
                <mi>stmt</mi>
            </math>
        </li>
    </ol>
    <p>这种文法对于输入:</p>
    <div>if (E1)</div>
    <div>&nbsp;&nbsp;if (E2)</div>
    <div>&nbsp;&nbsp;&nbsp;&nbsp;stmt1</div>
    <div>&nbsp;&nbsp;<em>else</em></div>
    <div>&nbsp;&nbsp;&nbsp;&nbsp;<em>stmt2</em></div>
    <p>对于上述输入的else应该和E1的if语句匹配还是和E2的语句匹配都符合我们的文法,主流的编程语言都会让else和最近的if语句匹配,所以上述文法很明显做不到这一点。所以我们设计文法的时候就不能设计出上面这种二义性文法(或者我们在分析的时候做一些特殊处理,比如yacc遇到shift-reduce
        conflict的时候默认选择shift动作,刚好解决了if-else二义性问题)。</p>
    <h2>LL(k)文法分析器</h2>
    <p>LL是left to right,leftmost derivation的缩写,括号中的K指的是我们需要从源码中提前读取K个符号就能进行文法分析工作</p>
    <h3>LL(1)</h3>
    <p>
        目前很多编程语言是作者手写递归下降文法解析器,比如GCC、Go(GCC开始是用bison生成的LALR自顶向上分析器,后来改手写了<em>忘了OpenJDK是不是了)</em>。有的前端用的是LR(k)自底向上分析器,比如MySQL的SQL解析器、Linux的Bash
        shell就是用bison生成的LALR分析器--
        <q cite="https://en.wikipedia.org/wiki/GNU_Bison#Use"><a href="https://en.wikipedia.org/wiki/GNU_Bison#Use">GNU
                Bison</a></q>
        ,其实从GCC和Go改用手写文法解析器可以看出,做一个编译器前端并不是那么难。我个人认为他们改成手写解析器的一个原因是因为Bison不太方便扩展,如果要加一些定制功能,可能用bison更不容易开发,比如一些错误代码的提示和兼容,尤其是MySQL,如果一段很长的SQL报错,错误提示真的让人头大。而且为什么手写文法解析器都采用LL分析模式,而不用LR分析模式,我觉得是因为LR的分析模式状态数量太多了,人脑可能无法处理这么多状态。接下来就说明一下LL(1)文法分析器的工作流程。
    </p>
    <p>首先给定一个文法G,然后我们根据这个文法生成一个预测分析表,能正确生成这个分表的文法我们就称之为LL(1)文法。假设我们有一个文法G如下:</p>
    <ol>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mi>E</mi>
                <mo>+</mo>
                <mi>E</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mo>(</mo>
                <mi>E</mi>
                <mo>)</mo>
            </math>
            <em>这里的n表示一个数字</em>
        </li>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mi>n</mi>
            </math>
        </li>
    </ol>
    <p>我们把上述文法稍做改造,改成这样(<em>LL(1)分析器不能处理左递归文法,我们通过改造消除了左递归,但是仍然没有消除二义性,但是并不影响我们的课程,后面我会对这个文法改造一下,变成无二义性的文法)</em>):</p>
    <ol>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mo>(</mo>
                <mi>E</mi>
                <mo>)</mo>
                <mi>E'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>E</mi>
                <mo>→</mo>
                <mo>n</mo>
                <mi>E'</mi>
            </math>
        </li>
        <li>
            <math>
                <mi>E'</mi>
                <mo>→</mo>
                <mo>+</mo>
                <mi>E</mi>
                <mo>E'</mo>
            </math>
        </li>
        <li>
            <math>
                <mi>E'</mi>
                <mo>→</mo>
                <mi>ε</mi>
            </math>
        </li>
    </ol>
    <p>然后我们用如下规则对文法G构造一个预测分析表:</p>
    <div>
        <span>我们对文法G中的每个产生式<math>
                <mi>A</mi>
                <mo>→</mo>
                <mi>α</mi>
            </math>进行如下处理</span>
        <ol>
            <li>对于first(α)中的每个终结符号a,将<math>
                    <mi>A</mi>
                    <mo>→</mo>
                    <mi>α</mi>
                </math>加入到<math>
                    <mi>M</mi>
                    <mo>[</mo>
                    <mi>A</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo>]</mo>
                </math>中</li>
            <li>如果first(α)含有符号ε,则对follow(A)中的每个符号b,将<math>
                    <mi>A</mi>
                    <mo>→</mo>
                    <mi>α</mi>
                </math>加入到<math>
                    <mi>M</mi>
                    <mo>[</mo>
                    <mi>A</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo>]</mo>
                </math>中</li>
        </ol>
    </div>
    <p>我们从头来一遍,生成一个预测分析表</p>
    <ol>
        <li>
            <span>first集</span>
            <table>
                <tbody>
                    <tr>
                        <td>first(E)</td>
                        <td>(</td>
                        <td>n</td>
                    </tr>
                    <tr>
                        <td>first(E')</td>
                        <td>+</td>
                        <td>ε</td>
                    </tr>
                </tbody>
            </table>
        </li>
        <li>
            <span>follow集,因为产生式3对E'有右递归,所以在计算follow(E')的时候被忽略,然后E'仅仅出现在产生式1、2的末尾,所以follow(E')=follow(E)</span>
            <table>
                <tbody>
                    <tr>
                        <td>follow(E)</td>
                        <td>+</td>
                        <td>)</td>
                        <td>$</td>
                    </tr>
                    <tr>
                        <td>follow(E')</td>
                        <td>+</td>
                        <td>)</td>
                        <td>$</td>
                    </tr>
                </tbody>
            </table>
        </li>
        <li>
            分析表:
            <table>
                <thead>
                    <tr>
                        <td rowspan="2">非终结符</td>
                        <td colspan="5">输入符号</td>
                    </tr>
                    <tr>
                        <td>(</td>
                        <td>)</td>
                        <td>n</td>
                        <td>+</td>
                        <td>$</td>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>E</td>
                        <td>E → ( E ) E'</td>
                        <td></td>
                        <td>E → n E'</td>
                        <td></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td>E'</td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td>E' → + E E'<br />E' → ε<br />(根据规则first(α)含有符号ε,则添加follow(A))</td>
                        <td>E' → ε<br />(根据规则first(α)含有符号ε,则添加follow(A))</td>
                    </tr>
                </tbody>
            </table>
        </li>
        <li>
            预测分析表中的每一行的每个格子表示假设遇到这一列对应的终结符输入时,应该选择哪个产生式进行展开,空白表示语法错误,无法展开。而一个格子有多条产生式时,表示这个文法有二义性,不是一个合法的LL(1)文法。<em>上面这个文法因为前面说的二义性,有个格子包含了两条产生式</em><br />
            接下来我们就可以用这个分析表做编译器的parser了(需要注意的是我们说过了LL(1)不能处理二义性文法,这个文法目前仍然是有二义性的),预测分析表用法如下:
        </li>
    </ol>
    <h3>LL(1)分析器工作流程</h3>
    <p>有了预测分析表之后,就可以使用这个预测分析表驱动LL(1)分析器对源码进行解析。预测分析表的作用是:如果当前希望把源码输入的部分串规约成一个AST子树(每个AST子树都对应了一个非终结符),则这个非终结符面对不同的源码输入时,应该如何选择对应的产生式进行展开(replace)。我们使用符号栈表示<em>期待的符号</em>,每次解析初始化的时候,格局(中文龙书把configuration翻译成格局)如下:
    </p>
    <div style="display: flex;">
        <table>
            <thead>
                <tr>
                    <th colspan="3">栈</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>$</td>
                    <td>S</td>
                    <td></td>
                </tr>
            </tbody>
        </table>
        <div style="width: 1rem;"></div>
        <table>
            <thead>
                <tr>
                    <th colspan="6">输入</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>+</td>
                    <td>2</td>
                    <td>+</td>
                    <td>3</td>
                    <td>$</td>
                </tr>
            </tbody>
        </table>
    </div>
    <p>S表示每个文法的起始符号,$表示源码结束标识,然后按照如下流程处理源码</p>
    <ol>
        <li>
            <span id="ll1_1">从栈中弹出一个符号A(如果栈为空,则表示整个源码已经解析完毕),然后从输入中读取一个符号b</span>
            <ol type="a" style="color: inherit;">
                <li>
                    <span id="ll1_1_a_1">如果A是一个非终结符,则读取预测表中的<math>
                            <mi>M</mi>
                            <mo>[</mo>
                            <mi>A</mi>
                            <mo>,</mo>
                            <mi>b</mi>
                            <mo>]</mo>
                            <mo>=</mo>
                            <mi>A</mi>
                            <mo>→</mo>
                            <msub>
                                <mi>X</mi>
                                <mn>1</mn>
                            </msub>
                            <msub>
                                <mi>X</mi>
                                <mn>2</mn>
                            </msub>
                            <msub>
                                <mi>X</mi>
                                <mn>3</mn>
                            </msub>
                        </math>,然后把<math>
                            <msub>
                                <mi>X</mi>
                                <mn>3</mn>
                            </msub>
                            <msub>
                                <mi>X</mi>
                                <mn>2</mn>
                            </msub>
                            <msub>
                                <mi>X</mi>
                                <mn>1</mn>
                            </msub>
                        </math>(注意这里是逆序)压栈,</span><span id="ll1_1_a_2">并且回退输入符号b</span>。如果<math>
                        <mi>M</mi>
                        <mo>[</mo>
                        <mi>A</mi>
                        <mo>,</mo>
                        <mi>b</mi>
                        <mo>]</mo>
                    </math>是一个空白单元格,则语法错误
                </li>
                <li id="ll1_1_b">如果A是一个终结符,如果A=b,则回到步骤1,否则报语法错误</li>
            </ol>
        </li>
    </ol>
    <p>我们在执行上述循环的时候,已经在构建AST了,<em>从栈中弹出符号时,表示我们正在以这个符号作为root构造子树,条件a的压栈操作则表示我们已经用这个产生式构造出了root的所有下一层子节点</em>(我们实际运行的时候可以发现这个树是从顶部到底部,从左子树到右子树的建立流程,类似树的先序遍历,这也是LL(1)的由来)。
    </p>
    <p>前面说过这个文法有二义性,不能正确生成预测分析表,所以我重新设计了一个文法,并用这个文法演示AST的生成,可以在下面观看动画</p>
    <div>
        <div style="display: inline-block;">
            <ol>
                <li>文法:
                    <ol>
                        <li>
                            <math>
                                <mn>E</mn>
                                <mo>→</mo>
                                <mn>E</mn>
                                <mo>+</mo>
                                <mn>T</mn>
                            </math>
                        </li>
                        <li>
                            <math>
                                <mn>E</mn>
                                <mo>→</mo>
                                <mn>T</mn>
                            </math>
                        </li>
                        <li>
                            <math>
                                <mn>T</mn>
                                <mo>→</mo>
                                <mn>id</mn>
                            </math>
                        </li>
                    </ol>
                </li>
                <li>
                    消除左递归:
                    <ol>
                        <li>
                            <math>
                                <mn>E</mn>
                                <mo>→</mo>
                                <mo>T</mo>
                                <mn>E'</mn>
                            </math>
                        </li>
                        <li>
                            <math>
                                <mn>E'</mn>
                                <mo>→</mo>
                                <mo>+</mo>
                                <mo>T</mo>
                                <mo>E'</mo>
                            </math>
                        </li>
                        <li>
                            <math>
                                <mn>E'</mn>
                                <mo>→</mo>
                                <mo>ε</mo>
                            </math>
                        </li>
                        <li>
                            <math>
                                <mn>T</mn>
                                <mo>→</mo>
                                <mo>id</mo>
                            </math>
                        </li>
                    </ol>
                </li>
                <li>
                    <ol>
                        <li>first集:
                            <table>
                                <tbody>
                                    <tr>
                                        <td>first(E)</td>
                                        <td colspan="2">id</td>
                                    </tr>
                                    <tr>
                                        <td>first(E')</td>
                                        <td>+</td>
                                        <td>ε</td>
                                    </tr>
                                    <tr>
                                        <td>first(T)</td>
                                        <td colspan="2">id</td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                        <li>follow集:
                            <table>
                                <tbody>
                                    <tr>
                                        <td>follow(E)</td>
                                        <td>$</td>
                                    </tr>
                                    <tr>
                                        <td>follow(E')</td>
                                        <td>$</td>
                                    </tr>
                                    <tr>
                                        <td>follow(T)</td>
                                        <td>$</td>
                                    </tr>
                                </tbody>
                            </table>
                        </li>
                    </ol>
                </li>
                <li>
                    预测分析表:
                    <table>
                        <tbody id="ll1_table">
                            <tr>
                                <td rowspan="2">非终结符</td>
                                <td colspan="3">输入符号</td>
                            </tr>
                            <tr>
                                <td>id</td>
                                <td>+</td>
                                <td>$</td>
                            </tr>
                            <tr>
                                <td>E</td>
                                <td>
                                    <math>
                                        <mn>E</mn>
                                        <mo>→</mo>
                                        <mo>T</mo>
                                        <mn>E'</mn>
                                    </math>
                                </td>
                                <td></td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>E'</td>
                                <td></td>
                                <td>
                                    <math>
                                        <mn>E'</mn>
                                        <mo>→</mo>
                                        <mo>+</mo>
                                        <mo>T</mo>
                                        <mo>E'</mo>
                                    </math>
                                </td>
                                <td>
                                    <math>
                                        <mn>E'</mn>
                                        <mo>→</mo>
                                        <mo>ε</mo>
                                    </math>
                                </td>
                            </tr>
                            <tr>
                                <td>T</td>
                                <td>
                                    <math>
                                        <mn>T</mn>
                                        <mo>→</mo>
                                        <mo>id</mo>
                                    </math>
                                </td>
                                <td></td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </li>
            </ol>
        </div>
        <div style="display: inline-block;">
            动画:(好麻烦啊)<button id="ll1_next">下一步</button>
            <ol>
                <li>格局(假设1+2+3已经被词法分析器解析成id(1)+id(2)+id(3)):
                    <ul>
                        <li>输入:
                            <span id="ll1_input">
                                <span>id(1)</span>
                                <span>+</span>
                                <span>id(2)</span>
                                <span>+</span>
                                <span>id(3)</span>
                                <span>$</span>
                            </span>
                        </li>
                        <li>栈:<span id="ll1_stack">
                                <span>$</span>
                                <span>E</span>
                            </span></li>
                    </ul>
                </li>
                <li>
                    <span>AST:</span>
                    <div style="width: 300px;">
                        <svg id="ll1_svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 118 180">
                            <text transform="translate(4.25 161.26)" style="font-family: DengXian, DengXian;">
                                <tspan x="0" y="0" style="fill: #000; font-size: 12px;">id</tspan>
                                <tspan x="9.57" y="0" style="fill: red; font-size: 6px;">(1)</tspan>
                            </text>
                            <path
                                d="M12.5,146c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M12.5,145c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                style="fill: #000; stroke-width: 0px;" />
                            <text transform="translate(97.25 171.26)" style="font-family: DengXian, DengXian;">
                                <tspan x="0" y="0" style="fill: #000; font-size: 12px;">id</tspan>
                                <tspan x="9.57" y="0" style="fill: red; font-size: 6px;">(1)</tspan>
                            </text>
                            <path
                                d="M105.5,156c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M105.5,155c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                style="fill: #000; stroke-width: 0px;" />
                            <text transform="translate(57.25 120.26)" style="font-family: DengXian, DengXian;">
                                <tspan x="0" y="0" style="fill: #000; font-size: 12px;">id</tspan>
                                <tspan x="9.57" y="0" style="fill: red; font-size: 6px;">(1)</tspan>
                            </text>
                            <path
                                d="M65.5,105c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M65.5,104c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                style="fill: #000; stroke-width: 0px;" />
                            <g id="E">
                                <text transform="translate(46.12 16.26)"
                                    style="fill: #000; font-family: DengXian, DengXian; font-size: 12px;">
                                    <tspan x="0" y="0">E</tspan>
                                </text>
                                <g>
                                    <path id="E_circle"
                                        d="M49.5,1c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5S43.16,1,49.5,1M49.5,0c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5S56.4,0,49.5,0h0Z"
                                        style="fill: #000; stroke-width: 0px;" />
                                </g>
                            </g>
                            <text transform="translate(61.87 171.26)"
                                style="fill: #000; font-family: DengXian, DengXian; font-size: 12px;">
                                <tspan x="0" y="0">+</tspan>
                            </text>
                            <path
                                d="M65.5,156c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M65.5,155c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                style="fill: #000; stroke-width: 0px;" />
                            <g id="T">
                                <text transform="translate(23.12 56.26)"
                                    style="fill: #000; font-family: DengXian, DengXian; font-size: 12px;">
                                    <tspan x="0" y="0">T</tspan>
                                </text>
                                <g>
                                    <path id="T_circle"
                                        d="M26.5,41c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M26.5,40c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                        style="fill: #000; stroke-width: 0px;" />
                                </g>
                            </g>
                            <line id="E_T" x1="39" y1="25" x2="32" y2="38"
                                style="fill: none; stroke: #000; stroke-miterlimit: 10;" />
                            <g id="Ep">
                                <text transform="translate(67.12 55.26)"
                                    style="fill: #000; font-family: DengXian, DengXian; font-size: 12px;">
                                    <tspan x="0" y="0">E’</tspan>
                                </text>
                                <g>
                                    <path id="Ep_circle"
                                        d="M70.5,40c6.34,0,11.5,5.16,11.5,11.5s-5.16,11.5-11.5,11.5-11.5-5.16-11.5-11.5,5.16-11.5,11.5-11.5M70.5,39c-6.9,0-12.5,5.6-12.5,12.5s5.6,12.5,12.5,12.5,12.5-5.6,12.5-12.5-5.6-12.5-12.5-12.5h0Z"
                                        style="fill: #000; stroke-width: 0px;" />
                                </g>
                            </g>
                            <line id="E_Ep" x1="58" y1="24" x2="66" y2="38"
                                style="fill: none; stroke: #000; stroke-miterlimit: 10;" />
                        </svg>
                    </div>
            </ol>
        </div>
    </div>
    <h2>动画太麻烦了,先睡觉,后面的LR文法分析器不做动画了,这么多状态要画死人</h2>
    <h2>LR分析器</h2>
    <p>LR(1)为什么不需要follow集,LR(0)没有这种顾虑</p>
</body>

<script type="module" src="./js/NFA-1.js">
</script>
<script type="module" src="./js/NFA-2-DFA.js">
</script>
<script type="module" src="./js/LL(1).js">
</script>

</html>
